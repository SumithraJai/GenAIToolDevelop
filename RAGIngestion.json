{
  "message": "### Code Snippet Extraction\n\nThe provided JSON content contains a JavaScript code snippet. The code is extracted from the \"result\" key in the JSON object.\n\n#### Extracted Code Snippet\n\n```javascript\n/**\n * Thischrome.action.onClicked.addListener((tab) => {\n  // This opens the side panel in Chrome (Experimental APIs).\n  // Adjust if you're using a different approach or want to open a popup window, etc.\n  try {\n    if (chrome.sidePanel && chrome.sidePanel.open) {\n      chrome.sidePanel.open({ windowId: tab.windowId });\n    } else {\n      console.warn('Side panel API not available, opening popup instead');\n      chrome.windows.create({\n        url: chrome.runtime.getURL('panel.html'),\n        type: 'popup',\n        width: 400,\n        height: 600\n      });\n    }\n  } catch (error) {\n    console.error('Error opening side panel:', error);\n    // Fallback to popup\n    chrome.windows.create({\n      url: chrome.runtime.getURL('panel.html'),\n      type: 'popup',\n      width: 400,\n      height: 600\n    });\n  }\n});\ny will hold the aggregated selections from content.js.\n * Alternatively, you can store them directly in chrome.storage.sync\n * after each new selection rather than keeping them in memory.\n */\nlet selectedElements = [];\n\n/**\n * Handler: When the user clicks the extension\u2019s toolbar icon,\n * we open or focus the side panel associated with the current window.\n */\nchrome.action.onClicked.addListener((tab) => {\n  // This opens the side panel in Chrome (Experimental APIs).\n  // Adjust if you\u2019re using a different approach or want to open a popup window, etc.\n  chrome.sidePanel.open({ windowId: tab.windowId });\n});\n\n/**\n * Listen for messages from content.js or other parts of the extension.\n */\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message.type === 'SELECTED_DOM_CONTENT') {\n    /**\n     * content.js is sending the combined outerHTML of all currently selected elements.\n     * Usually, you'll want to store each update or the final snippet for the user\u2019s next step.\n     */\n    console.log('[background.js] Received snippet:\\n', message.content);\n\n    const combinedSnippet = message.content; // string of concatenated outerHTML lines\n\n    // For demonstration, store in memory:\n    selectedElements = [combinedSnippet];\n\n    // Also store it in chrome.storage.sync for easy retrieval in sidepanel or chat:\n    chrome.storage.local.set({ combinedDomSnippet: combinedSnippet }, () => {\n      console.log('[background] Stored combinedDomSnippet in chrome.storage.local:', combinedSnippet);\n    });\n\n    sendResponse({ success: true });\n    return true; // async\n  }\n\n  // Handle GitHub API requests\n  if (message.type === 'GITHUB_API_REQUEST') {\n    // Use async/await pattern that works with Chrome extension messaging\n    (async () => {\n      try {\n        const result = await handleGitHubAPIRequest(message);\n        sendResponse(result);\n      } catch (error) {\n        sendResponse({\n          success: false,\n          status: 0,\n          data: null,\n          error: error.message\n        });\n      }\n    })();\n    return true; // Keep the message channel open for async response\n  }\n\n  return false; // no other message types handled\n});\n\n/**\n * Handle GitHub API requests from the extension pages\n */\nasync function handleGitHubAPIRequest(message) {\n  console.log('[background] Handling GitHub API request:', message.url);\n  try {\n    const { url, options } = message;\n    console.log('[background] Making fetch request to:', url);\n    const response = await fetch(url, options);\n    console.log('[background] Fetch response status:', response.status);\n    \n    let data = {};\n    try {\n      data = await response.json();\n    } catch (jsonError) {\n      console.log('[background] JSON parse error (expected for some responses):', jsonError.message);\n    }\n    \n    const result = {\n      success: response.ok,\n      status: response.status,\n      data: data,\n      error: response.ok ? null : `GitHub API error: ${response.status} - ${data.message || 'Unknown error'}`\n    };\n    \n    console.log('[background] Returning result:', result);\n    return result;\n  } catch (error) {\n    console.error('[background] Network error:', error);\n    return {\n      success: false,\n      status: 0,\n      data: null,\n      error: `Network error: ${error.message}`\n    };\n  }\n}\n\n/**\n * Handle extension unload (e.g., browser shutting down, extension disabled).\n * We attempt to send a 'CLEANUP' message to each tab so it can remove highlights, etc.\n */\nchrome.runtime.onSuspend.addListener(async () => {\n  try {\n    const tabs = await chrome.tabs.query({});\n    for (const tab of tabs) {\n      try {\n        await chrome.tabs.sendMessage(tab.id, { type: 'CLEANUP' });\n      } catch (error) {\n        // Ignore errors for tabs where the content script is not running\n      }\n    }\n  } catch (error) {\n    console.error('Error during extension cleanup:', error);\n  }\n});\n```\n\n#### Language Identification\n\nThe extracted code snippet is written in **JavaScript**.\n\nSince the task is to identify and extract code snippets written in languages other than Java, and the provided code is in JavaScript, it meets the condition as JavaScript is not Java. \n\nTherefore, the extracted code snippet is the JavaScript code provided above."
}